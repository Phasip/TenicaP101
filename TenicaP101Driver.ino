#include <avr/pgmspace.h>
#include <avr/io.h> 
#include <avr/interrupt.h>

#define DISPLAYORDER LSBFIRST
#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
#define V(var) var?LOW:HIGH
#define ON(var) digitalWrite(var,LOW);
#define OFF(var) digitalWrite(var,HIGH);


#define BIT8 0x01
#define BIT7 0x02
#define BIT6 0x04
#define BIT5 0x08
#define BIT4 0x10
#define BIT3 0x20
#define BIT2 0x40
#define BIT1 0x80
#define ANY_BIT(valA,valB) ((!!(valA & valB)) ? 1 : 0)
const char bits[8] = {BIT1, BIT2, BIT3, BIT4, BIT5, BIT6, BIT7, BIT8};
uint8_t data[7][12];
//Rotate left, shift everything left and set the least significant bit to what the most significant bit was before
#define rol(val) val = val << 1 | !!(val & 0x80);
//Rotate right, same as left but backwards.
#define ror(val) val = val >> 1 | ((!!(val & 1)) ? 0x80 : 0);

// the loop routine runs over and over again forever:
byte charwidth = 5;
byte spacing = 2;
byte refreshPerStep = 1;
byte stepcounter = 0;
byte dir = 1;
byte rotate = 1;
byte disp[7][12];
void init_timer() {
	  cli();          // disable global interrupts
    TCCR1A = 0;     // set entire TCCR1A register to 0
    TCCR1B = 0;     // same for TCCR1B
 
    // set compare match register to desired timer count:
    OCR1A = 960;
    // turn on CTC mode:
    TCCR1B |= (1 << WGM12);
    // Set CS10 and CS12 bits for 1024 prescaler:
    TCCR1B |= (1 << CS10);
    TCCR1B |= (1 << CS11);
    // enable timer compare interrupt:
    TIMSK1 |= (1 << OCIE1A);
    sei();          // enable global interrupts
	/* Working
	cli();             // disable global interrupts
    TCCR1A = 0;        // set entire TCCR1A register to 0
    TCCR1B = 0;
 
    // enable Timer1 overflow interrupt:
    TIMSK1 = (1 << TOIE1);
    // Set CS10 bit so timer runs at clock speed:
    TCCR1B |= (1 << CS10);
    // enable global interrupts:
    sei();*/
    // enable interrupts

    // enable interrupts

	/*Working
	OCR2A = 0xFF;
    TCCR2A |= (1 << WGM21);
    // Set to CTC Mode
    TIMSK2 |= (1 << OCIE2A);
    //Set interrupt on compare match
    TCCR2B |= (1 << CS21);
    // set prescaler to 64 and starts PWM
    sei();
    // enable interrupts*/


}

void shiftOutRol(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	//This function is called a lot and probably earns much speed from the rol operator because
	//atmega328 only does one step shift making code like !!(val & 1 << i) "slow".
	//Note, probably a shift and a !!(val & 0x80) would be as fast (or faster).
	uint8_t i;

	 if (bitOrder == MSBFIRST) {
		 rol(val);
	 }
	for (i = 8; i > 0 ; i--)  {
		digitalWrite(dataPin, !!(val & 1));
		digitalWrite(clockPin, HIGH);
		digitalWrite(clockPin, LOW);
		if (bitOrder == MSBFIRST) {
					 rol(val);
		} else {
					 //No need for rotation here.
					 val = val >> 1;
		}
					
}
}

void shiftArray(uint8_t bitOrder, uint8_t row) {
	uint8_t tmp,tmp2;
	uint8_t i;
	
	//Theese two loops could probably be written "backwards" and save at least one tmp variable
	//But then they would be not so readable. I hope they are good enough.
	if (bitOrder == LSBFIRST) {
		tmp = 0;
		for (i = 12; i-- > 0; ) { //Cool unsigned decreasing loop
			tmp2 = data[row][i];
			data[row][i] = data[row][i] >> 1 | (tmp?0x80:0);
			tmp = tmp2 & 0x01;
		}
	} else {
		tmp = 0;
		for (i = 0; i < 12; i++) {
			tmp2 = !!(data[row][i] & 0x80);
			data[row][i] = data[row][i] << 1 | (tmp?1:0);
			tmp = tmp2;
		}
		
	}
}
void shiftOutArray(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t row) {
	if (bitOrder == LSBFIRST) {
		for (uint8_t i = 0; i < 12; i++) {
			shiftOutRol(dataPin,clockPin,bitOrder,data[row][i]);
		}
	} else {
		for (uint8_t i = 12; i-- > 0; ) { //Cool unsigned decreasing loop
			shiftOutRol(dataPin,clockPin,bitOrder,data[row][i]);
		}
	}
}

const byte CLK = 10;
const byte SIN = 9;
const byte list[] = {2,3,4,5,6,7,8,9,10};
const byte listlen = 9;

char charat[] = "Testing";
/*prog_uchar text[] PROGMEM  = "Annika 50            ";*/
short length = 0;
short counter = 0;
short at = 0;
byte partialCounter = 0;
const byte font[][5] = {
		{0x00,0x00,0x00,0x00,0x00},   //   0x20 32
		{0x00,0x00,0x6f,0x00,0x00},   // ! 0x21 33
		{0x00,0x07,0x00,0x07,0x00},   // " 0x22 34
		{0x14,0x7f,0x14,0x7f,0x14},   // # 0x23 35
		{0x00,0x07,0x04,0x1e,0x00},   // $ 0x24 36
		{0x23,0x13,0x08,0x64,0x62},   // % 0x25 37
		{0x36,0x49,0x56,0x20,0x50},   // & 0x26 38
		{0x00,0x00,0x07,0x00,0x00},   // ' 0x27 39
		{0x00,0x1c,0x22,0x41,0x00},   // ( 0x28 40
		{0x00,0x41,0x22,0x1c,0x00},   // ) 0x29 41
		{0x14,0x08,0x3e,0x08,0x14},   // * 0x2a 42
		{0x08,0x08,0x3e,0x08,0x08},   // + 0x2b 43
		{0x00,0x50,0x30,0x00,0x00},   // , 0x2c 44
		{0x08,0x08,0x08,0x08,0x08},   // - 0x2d 45
		{0x00,0x60,0x60,0x00,0x00},   // . 0x2e 46
		{0x20,0x10,0x08,0x04,0x02},   // / 0x2f 47
		{0x3e,0x51,0x49,0x45,0x3e},   // 0 0x30 48
		{0x00,0x42,0x7f,0x40,0x00},   // 1 0x31 49
		{0x42,0x61,0x51,0x49,0x46},   // 2 0x32 50
		{0x21,0x41,0x45,0x4b,0x31},   // 3 0x33 51
		{0x18,0x14,0x12,0x7f,0x10},   // 4 0x34 52
		{0x27,0x45,0x45,0x45,0x39},   // 5 0x35 53
		{0x3c,0x4a,0x49,0x49,0x30},   // 6 0x36 54
		{0x01,0x71,0x09,0x05,0x03},   // 7 0x37 55
		{0x36,0x49,0x49,0x49,0x36},   // 8 0x38 56
		{0x06,0x49,0x49,0x29,0x1e},   // 9 0x39 57
		{0x00,0x36,0x36,0x00,0x00},   // : 0x3a 58
		{0x00,0x56,0x36,0x00,0x00},   // ; 0x3b 59
		{0x08,0x14,0x22,0x41,0x00},   // < 0x3c 60
		{0x14,0x14,0x14,0x14,0x14},   // = 0x3d 61
		{0x00,0x41,0x22,0x14,0x08},   // > 0x3e 62
		{0x02,0x01,0x51,0x09,0x06},   // ? 0x3f 63
		{0x3e,0x41,0x5d,0x49,0x4e},   // @ 0x40 64
		{0x7e,0x09,0x09,0x09,0x7e},   // A 0x41 65
		{0x7f,0x49,0x49,0x49,0x36},   // B 0x42 66
		{0x3e,0x41,0x41,0x41,0x22},   // C 0x43 67
		{0x7f,0x41,0x41,0x41,0x3e},   // D 0x44 68
		{0x7f,0x49,0x49,0x49,0x41},   // E 0x45 69
		{0x7f,0x09,0x09,0x09,0x01},   // F 0x46 70
		{0x3e,0x41,0x49,0x49,0x7a},   // G 0x47 71
		{0x7f,0x08,0x08,0x08,0x7f},   // H 0x48 72
		{0x00,0x41,0x7f,0x41,0x00},   // I 0x49 73
		{0x20,0x40,0x41,0x3f,0x01},   // J 0x4a 74
		{0x7f,0x08,0x14,0x22,0x41},   // K 0x4b 75
		{0x7f,0x40,0x40,0x40,0x40},   // L 0x4c 76
		{0x7f,0x02,0x0c,0x02,0x7f},   // M 0x4d 77
		{0x7f,0x04,0x08,0x10,0x7f},   // N 0x4e 78
		{0x3e,0x41,0x41,0x41,0x3e},   // O 0x4f 79
		{0x7f,0x09,0x09,0x09,0x06},   // P 0x50 80
		{0x3e,0x41,0x51,0x21,0x5e},   // Q 0x51 81
		{0x7f,0x09,0x19,0x29,0x46},   // R 0x52 82
		{0x46,0x49,0x49,0x49,0x31},   // S 0x53 83
		{0x01,0x01,0x7f,0x01,0x01},   // T 0x54 84
		{0x3f,0x40,0x40,0x40,0x3f},   // U 0x55 85
		{0x0f,0x30,0x40,0x30,0x0f},   // V 0x56 86
		{0x3f,0x40,0x30,0x40,0x3f},   // W 0x57 87
		{0x63,0x14,0x08,0x14,0x63},   // X 0x58 88
		{0x07,0x08,0x70,0x08,0x07},   // Y 0x59 89
		{0x61,0x51,0x49,0x45,0x43},   // Z 0x5a 90
		{0x3c,0x4a,0x49,0x29,0x1e},   // [ 0x5b 91
		{0x02,0x04,0x08,0x10,0x20},   // \ 0x5c 92
		{0x00,0x41,0x7f,0x00,0x00},   // ] 0x5d 93
		{0x04,0x02,0x01,0x02,0x04},   // ^ 0x5e 94
		{0x40,0x40,0x40,0x40,0x40},   // _ 0x5f 95
		{0x00,0x00,0x03,0x04,0x00},   // ` 0x60 96
		{0x20,0x54,0x54,0x54,0x78},   // a 0x61 97
		{0x7f,0x48,0x44,0x44,0x38},   // b 0x62 98
		{0x38,0x44,0x44,0x44,0x20},   // c 0x63 99
		{0x38,0x44,0x44,0x48,0x7f},   // d 0x64 100
		{0x38,0x54,0x54,0x54,0x18},   // e 0x65 101
		{0x08,0x7e,0x09,0x01,0x02},   // f 0x66 102
		{0x0c,0x52,0x52,0x52,0x3e},   // g 0x67 103
		{0x7f,0x08,0x04,0x04,0x78},   // h 0x68 104
		{0x00,0x44,0x7d,0x40,0x00},   // i 0x69 105
		{0x20,0x40,0x44,0x3d,0x00},   // j 0x6a 106
		{0x00,0x7f,0x10,0x28,0x44},   // k 0x6b 107
		{0x00,0x41,0x7f,0x40,0x00},   // l 0x6c 108
		{0x7c,0x04,0x18,0x04,0x78},   // m 0x6d 109
		{0x7c,0x08,0x04,0x04,0x78},   // n 0x6e 110
		{0x38,0x44,0x44,0x44,0x38},   // o 0x6f 111
		{0x7c,0x14,0x14,0x14,0x08},   // p 0x70 112
		{0x08,0x14,0x14,0x18,0x7c},   // q 0x71 113
		{0x7c,0x08,0x04,0x04,0x08},   // r 0x72 114
		{0x48,0x54,0x54,0x54,0x20},   // s 0x73 115
		{0x04,0x3f,0x44,0x40,0x20},   // t 0x74 116
		{0x3c,0x40,0x40,0x20,0x7c},   // u 0x75 117
		{0x1c,0x20,0x40,0x20,0x1c},   // v 0x76 118
		{0x3c,0x40,0x30,0x40,0x3c},   // w 0x77 119
		{0x44,0x28,0x10,0x28,0x44},   // x 0x78 120
		{0x0c,0x50,0x50,0x50,0x3c},   // y 0x79 121
		{0x44,0x64,0x54,0x4c,0x44},   // z 0x7a 122
		{0x00,0x08,0x36,0x41,0x41},   // { 0x7b 123
		{0x00,0x00,0x7f,0x00,0x00},   // | 0x7c 124
		{0x41,0x41,0x36,0x08,0x00},   // } 0x7d 125
		{0x04,0x02,0x04,0x08,0x04},   // ~ 0x7e 126
	};
byte i = 0;
byte j = 0;
	void flashPin(byte pin, short length) {
  digitalWrite(pin,LOW);
  delayMicroseconds(length);
  digitalWrite(pin,HIGH);
  
}

void showDisplay(uint8_t order) {
    for (byte row = 0; row < 7; row++) { 
      byte place = 0;
      shiftOutArray(SIN,CLK,order,row); 
      flashPin(list[row],500);
    }
}
void showDisplay2() {
	showDisplay(LSBFIRST);
}
// the setup routine runs once when you press reset:
void setup() {
  for ( i = 0; i < listlen; i++) {
    pinMode(list[i], OUTPUT);
     OFF(list[i]);
  }
  	uint8_t x = 0;
	data[0][11] = 0xFF;
	data[0][10] = 0xFF;
	data[2][0] = 0xFF;
	init_timer();
}
int calcatLim(int nr,int lim) {
  if (nr >= lim) {
    return calcatLim(nr-lim,lim);
  }
  if (nr < 0 ) {
    return calcatLim(lim+nr,lim);
  }
  return nr;
}

//shiftOut(SIN, CLK,  MSBFIRST // LSBFIRST, value)


void tick(int d) {
  digitalWrite(CLK,LOW);
  digitalWrite(CLK,HIGH);
}
unsigned long *ptr;
unsigned long *ptr2;
double radians = 0;
double increase = 80.0f/180.0f;
void loop() {
	radians+=increase;
	for (i = 0; i < 7; i++) 
	{
		shiftArray(MSBFIRST,i);
		delay(3);
	}
	data[(int)(sin(radians)*4.0f)+3][0] |= 1;
}
uint8_t clock = 0;
ISR (TIMER1_COMPA_vect)
{
	digitalWrite(list[clock],HIGH);
	clock++;
	if (clock > 6) {
		clock = 0;
	}
	shiftOutArray(SIN,CLK,DISPLAYORDER,clock);
	digitalWrite(list[clock],LOW);
}