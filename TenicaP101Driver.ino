#include <avr/pgmspace.h>
#include <avr/io.h> 
#include <avr/interrupt.h>

#define DISPLAYORDER MSBFIRST
#define FRAMES 10
#define DELAY 10
#define V(var) var?LOW:HIGH
#define ON(var) digitalWrite(var,LOW);
#define OFF(var) digitalWrite(var,HIGH);


#define BIT8 0x01
#define BIT7 0x02
#define BIT6 0x04
#define BIT5 0x08
#define BIT4 0x10
#define BIT3 0x20
#define BIT2 0x40
#define BIT1 0x80
#define ANY_BIT(valA,valB) ((!!(valA & valB)) ? 1 : 0)
const char bits[8] = {BIT8, BIT7, BIT6, BIT5, BIT4, BIT3, BIT2, BIT1};
#define CHECK_BIT(var,pos) (!!((var) & bits[pos]))

uint8_t framedone[FRAMES];
uint8_t frames[FRAMES][7][12];
uint8_t data[7][12];
//Rotate left, shift everything left and set the least significant bit to what the most significant bit was before
#define rol(val) val = val << 1 | !!(val & 0x80);
//Rotate right, same as left but backwards.
#define ror(val) val = val >> 1 | ((!!(val & 1)) ? 0x80 : 0);

// the loop routine runs over and over again forever:
byte charwidth = 5;
byte spacing = 2;
byte disp[7][12];


void shiftOutRol(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	//This function is called a lot and probably earns much speed from the rol operator because
	//atmega328 only does one step shift making code like !!(val & 1 << i) "slow".
	//Note, probably a shift and a !!(val & 0x80) would be as fast (or faster).
	uint8_t i;

	 if (bitOrder == MSBFIRST) {
		 rol(val);
	 }
	for (i = 8; i > 0 ; i--)  {
		digitalWrite(dataPin, !!(val & 1));
		digitalWrite(clockPin, HIGH);
		digitalWrite(clockPin, LOW);
		if (bitOrder == MSBFIRST) {
					 rol(val);
		} else {
					 //No need for rotation here.
					 val = val >> 1;
		}
					
}
}

void shiftArray(uint8_t bitOrder, uint8_t row) {
	uint8_t tmp,tmp2;
	uint8_t i;
	
	//Theese two loops could probably be written "backwards" and save at least one tmp variable
	//But then they would be not so readable. I hope they are good enough.
	if (bitOrder == LSBFIRST) {
		tmp = 0;
		for (i = 12; i-- > 0; ) { //Cool unsigned decreasing loop
			tmp2 = data[row][i];
			data[row][i] = data[row][i] >> 1 | (tmp?0x80:0);
			tmp = tmp2 & 0x01;
		}
	} else {
		tmp = 0;
		for (i = 0; i < 12; i++) {
			tmp2 = !!(data[row][i] & 0x80);
			data[row][i] = data[row][i] << 1 | (tmp?1:0);
			tmp = tmp2;
		}
		
	}
}
void shiftOutArray(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t row,uint8_t (*data)[12]) {
	if (bitOrder == LSBFIRST) {
		for (uint8_t i = 0; i < 12; i++) {
			shiftOutRol(dataPin,clockPin,bitOrder,data[row][i]);
		}
	} else {
		for (uint8_t i = 12; i-- > 0; ) { //Cool unsigned decreasing loop
			shiftOutRol(dataPin,clockPin,bitOrder,data[row][i]);
		}
	}
}

const byte CLK = 10;
const byte SIN = 9;
const byte list[] = {2,3,4,5,6,7,8,9,10};
const byte listlen = 9;

short length = 0;
//Array taken from http://playground.arduino.cc/Code/PCD8544
const byte font[][5] = {
		{0x00,0x00,0x00,0x00,0x00},   //   0x20 32
		{0x00,0x00,0x6f,0x00,0x00},   // ! 0x21 33
		{0x00,0x07,0x00,0x07,0x00},   // " 0x22 34
		{0x14,0x7f,0x14,0x7f,0x14},   // # 0x23 35
		{0x00,0x07,0x04,0x1e,0x00},   // $ 0x24 36
		{0x23,0x13,0x08,0x64,0x62},   // % 0x25 37
		{0x36,0x49,0x56,0x20,0x50},   // & 0x26 38
		{0x00,0x00,0x07,0x00,0x00},   // ' 0x27 39
		{0x00,0x1c,0x22,0x41,0x00},   // ( 0x28 40
		{0x00,0x41,0x22,0x1c,0x00},   // ) 0x29 41
		{0x14,0x08,0x3e,0x08,0x14},   // * 0x2a 42
		{0x08,0x08,0x3e,0x08,0x08},   // + 0x2b 43
		{0x00,0x50,0x30,0x00,0x00},   // , 0x2c 44
		{0x08,0x08,0x08,0x08,0x08},   // - 0x2d 45
		{0x00,0x60,0x60,0x00,0x00},   // . 0x2e 46
		{0x20,0x10,0x08,0x04,0x02},   // / 0x2f 47
		{0x3e,0x51,0x49,0x45,0x3e},   // 0 0x30 48
		{0x00,0x42,0x7f,0x40,0x00},   // 1 0x31 49
		{0x42,0x61,0x51,0x49,0x46},   // 2 0x32 50
		{0x21,0x41,0x45,0x4b,0x31},   // 3 0x33 51
		{0x18,0x14,0x12,0x7f,0x10},   // 4 0x34 52
		{0x27,0x45,0x45,0x45,0x39},   // 5 0x35 53
		{0x3c,0x4a,0x49,0x49,0x30},   // 6 0x36 54
		{0x01,0x71,0x09,0x05,0x03},   // 7 0x37 55
		{0x36,0x49,0x49,0x49,0x36},   // 8 0x38 56
		{0x06,0x49,0x49,0x29,0x1e},   // 9 0x39 57
		{0x00,0x36,0x36,0x00,0x00},   // : 0x3a 58
		{0x00,0x56,0x36,0x00,0x00},   // ; 0x3b 59
		{0x08,0x14,0x22,0x41,0x00},   // < 0x3c 60
		{0x14,0x14,0x14,0x14,0x14},   // = 0x3d 61
		{0x00,0x41,0x22,0x14,0x08},   // > 0x3e 62
		{0x02,0x01,0x51,0x09,0x06},   // ? 0x3f 63
		{0x3e,0x41,0x5d,0x49,0x4e},   // @ 0x40 64
		{0x7e,0x09,0x09,0x09,0x7e},   // A 0x41 65
		{0x7f,0x49,0x49,0x49,0x36},   // B 0x42 66
		{0x3e,0x41,0x41,0x41,0x22},   // C 0x43 67
		{0x7f,0x41,0x41,0x41,0x3e},   // D 0x44 68
		{0x7f,0x49,0x49,0x49,0x41},   // E 0x45 69
		{0x7f,0x09,0x09,0x09,0x01},   // F 0x46 70
		{0x3e,0x41,0x49,0x49,0x7a},   // G 0x47 71
		{0x7f,0x08,0x08,0x08,0x7f},   // H 0x48 72
		{0x00,0x41,0x7f,0x41,0x00},   // I 0x49 73
		{0x20,0x40,0x41,0x3f,0x01},   // J 0x4a 74
		{0x7f,0x08,0x14,0x22,0x41},   // K 0x4b 75
		{0x7f,0x40,0x40,0x40,0x40},   // L 0x4c 76
		{0x7f,0x02,0x0c,0x02,0x7f},   // M 0x4d 77
		{0x7f,0x04,0x08,0x10,0x7f},   // N 0x4e 78
		{0x3e,0x41,0x41,0x41,0x3e},   // O 0x4f 79
		{0x7f,0x09,0x09,0x09,0x06},   // P 0x50 80
		{0x3e,0x41,0x51,0x21,0x5e},   // Q 0x51 81
		{0x7f,0x09,0x19,0x29,0x46},   // R 0x52 82
		{0x46,0x49,0x49,0x49,0x31},   // S 0x53 83
		{0x01,0x01,0x7f,0x01,0x01},   // T 0x54 84
		{0x3f,0x40,0x40,0x40,0x3f},   // U 0x55 85
		{0x0f,0x30,0x40,0x30,0x0f},   // V 0x56 86
		{0x3f,0x40,0x30,0x40,0x3f},   // W 0x57 87
		{0x63,0x14,0x08,0x14,0x63},   // X 0x58 88
		{0x07,0x08,0x70,0x08,0x07},   // Y 0x59 89
		{0x61,0x51,0x49,0x45,0x43},   // Z 0x5a 90
		{0x3c,0x4a,0x49,0x29,0x1e},   // [ 0x5b 91
		{0x02,0x04,0x08,0x10,0x20},   // \ 0x5c 92
		{0x00,0x41,0x7f,0x00,0x00},   // ] 0x5d 93
		{0x04,0x02,0x01,0x02,0x04},   // ^ 0x5e 94
		{0x40,0x40,0x40,0x40,0x40},   // _ 0x5f 95
		{0x00,0x00,0x03,0x04,0x00},   // ` 0x60 96
		{0x20,0x54,0x54,0x54,0x78},   // a 0x61 97
		{0x7f,0x48,0x44,0x44,0x38},   // b 0x62 98
		{0x38,0x44,0x44,0x44,0x20},   // c 0x63 99
		{0x38,0x44,0x44,0x48,0x7f},   // d 0x64 100
		{0x38,0x54,0x54,0x54,0x18},   // e 0x65 101
		{0x08,0x7e,0x09,0x01,0x02},   // f 0x66 102
		{0x0c,0x52,0x52,0x52,0x3e},   // g 0x67 103
		{0x7f,0x08,0x04,0x04,0x78},   // h 0x68 104
		{0x00,0x44,0x7d,0x40,0x00},   // i 0x69 105
		{0x20,0x40,0x44,0x3d,0x00},   // j 0x6a 106
		{0x00,0x7f,0x10,0x28,0x44},   // k 0x6b 107
		{0x00,0x41,0x7f,0x40,0x00},   // l 0x6c 108
		{0x7c,0x04,0x18,0x04,0x78},   // m 0x6d 109
		{0x7c,0x08,0x04,0x04,0x78},   // n 0x6e 110
		{0x38,0x44,0x44,0x44,0x38},   // o 0x6f 111
		{0x7c,0x14,0x14,0x14,0x08},   // p 0x70 112
		{0x08,0x14,0x14,0x18,0x7c},   // q 0x71 113
		{0x7c,0x08,0x04,0x04,0x08},   // r 0x72 114
		{0x48,0x54,0x54,0x54,0x20},   // s 0x73 115
		{0x04,0x3f,0x44,0x40,0x20},   // t 0x74 116
		{0x3c,0x40,0x40,0x20,0x7c},   // u 0x75 117
		{0x1c,0x20,0x40,0x20,0x1c},   // v 0x76 118
		{0x3c,0x40,0x30,0x40,0x3c},   // w 0x77 119
		{0x44,0x28,0x10,0x28,0x44},   // x 0x78 120
		{0x0c,0x50,0x50,0x50,0x3c},   // y 0x79 121
		{0x44,0x64,0x54,0x4c,0x44},   // z 0x7a 122
		{0x00,0x08,0x36,0x41,0x41},   // { 0x7b 123
		{0x00,0x00,0x7f,0x00,0x00},   // | 0x7c 124
		{0x41,0x41,0x36,0x08,0x00},   // } 0x7d 125
		{0x04,0x02,0x04,0x08,0x04},   // ~ 0x7e 126
	};
uint8_t i = 0;

/*
  Initializes a timer, see ISR (TIMER1_COMPA_vect)
*/
void init_timer() {
	  cli();          // disable global interrupts
    TCCR1A = 0;     // set entire TCCR1A register to 0
    TCCR1B = 0;     // same for TCCR1B
 
    // set compare match register to desired timer count:
    OCR1A = 1000;
    // turn on CTC mode:
    TCCR1B |= (1 << WGM12);
    // Set CS10 and CS12 bits for 1024 prescaler:
    TCCR1B |= (1 << CS10);
    TCCR1B |= (1 << CS11);
    // enable timer compare interrupt:
    TIMSK1 |= (1 << OCIE1A);
    sei();          // enable global interrupts
}

//Initialize for displaying stuff
void setup() {
  //Clear the values of pins.
  for ( i = 0; i < listlen; i++) {
    pinMode(list[i], OUTPUT);
     OFF(list[i]);
  }
  //Start our frame drawer timer.
  init_timer();
}


char text[] = "Pasi says hello!   ";
uint8_t charat = 0;
uint8_t colat = 0;
void drawText() {
	uint8_t i;
	length = 18;
	for (i = 0; i < 7; i++) {
		shiftArray(MSBFIRST,i);
	}
	
	for (i = 0; i < 7; i++) {
		if (colat < charwidth) {
			char f = font[text[charat]-32][colat];
			data[i][0] |= CHECK_BIT(f,i);
		}
	}
	colat++;
	if (colat >= charwidth+spacing-1) {
		colat = 0;
		charat++;
	}
	if (charat >= length) {
		charat = 0;
	}
}

/*
Main program loop, calls a function such as drawSinCruve or drawText,
these modify the data variable to be the next frame. after this it
copies the new frame into the frames array, after which it marks
the frame as done.

Also, if no frame is free it waits.
*/
uint8_t loopframeAt = 0;
void loop() {
        uint8_t j;
        
        //No frames free, wait.
        if (framedone[loopframeAt] == 1) {
          delay(5);
          return;
        }
        //Call drawer here
        drawText();
        //Copy frame to frame queue.
        for (i = 0; i < 7; i++) {
          for (j = 0; j < 12; j++) {
            frames[loopframeAt][i][j] = data[i][j];
          }
        }
        //mark frame as done and delay
        framedone[loopframeAt] = 1;
        delay(DELAY);
        loopframeAt++;
        if (loopframeAt >= FRAMES) {
          loopframeAt = 0;
        }
}

//Sin curve loop, fast 
double radians = 0;
double increase = 80.0f/180.0f;
void drawSinCurve() {

	radians+=increase;
	for (i = 0; i < 7; i++) 
	{
		shiftArray(MSBFIRST,i);
		
	}
	data[(int)(sin(radians)*4.0f)+3][0] |= 1;
}

/*
  Ugly timer that handles the drawing of a frame, each tick one row of the display is updated,
  if there's no new frame we continue drawing the old frame.
*/
uint8_t clock = 0;
uint8_t frameAt = 0;
uint8_t lastFrame = -1;
ISR (TIMER1_COMPA_vect)
{
        boolean hasNewFrame = framedone[frameAt] == 1;
        boolean hasOldFrame = lastFrame != -1;
        
        if (!hasNewFrame && !hasOldFrame)
          return;
	digitalWrite(list[clock],HIGH);

	clock++;
        //If we have updated all rows reset clock and try to advance to the next frame.
	if (clock > 6) {
	  clock = 0;
          if (hasNewFrame) {
            if (hasOldFrame)
              framedone[lastFrame] = 0; //Mark frame as viewed.
              
            lastFrame = frameAt;
            frameAt++;
            if (frameAt >= FRAMES) {
              frameAt = 0;
            }
          }
	}


        if (framedone[frameAt] == 1)
        	shiftOutArray(SIN,CLK,DISPLAYORDER,clock,frames[frameAt]);
        else if (lastFrame != -1)
        	shiftOutArray(SIN,CLK,DISPLAYORDER,clock,frames[lastFrame]);
        
	digitalWrite(list[clock],LOW);

}
